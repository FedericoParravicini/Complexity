
public abstract class Utils {
	
	public void nwise() {
		
	}
	
	public void callerframe() {
		
	}
	
	public void patch() {
		
	}
	
	public void unpatch() {
		
	}
	
	public void getModel() {
		
	}
	
	public void toPythonValue() {
		
	}
	
	public void conjuncts() {
		//GeneticExecutor -> pc_to_constraint_set
	}
	
	public void modelToDict() {
		
	}
	
	public void cleanBenchmarkString() {
		
	}
	
	public void solverToPc() {
		
	}
	
	public void toSmt2() {
		//Class INDIVIDUAL -> __reduce__
	}
	
	public void negate() {
		//CrossoverFunction -> union_crossover & MutationFunction -> negate_mutation
	}
	
	public void modelDictToString() {
		//worst_case_model = model_dict_to_string(profiles[0].model)
	}
	
	public void ppModelDict() {
		
	}
	
	public void unravel() {
		
	}
	
	public void mostCommon() {
		
	}
	
	public void pickProb() {
		
	}
	
	public void assertInRange() {
		
	}
	
	public void assertSorted() {
		
	}
	
	public void assertAllDifferent() {
		
	}
	
	public void assertAllPositive() {
		
	}
	
	public void override() {
		
	}
	
	public void ppWcetProfiles() {
		//GenticExecutor -> run
	}
	
	public void stopwatch() {
		
	}
	
	public void toAstArray() {
		
	}
	
	public void mkNot() {
		//SelectionFunction -> localSearch
	}
	
	public void mkAnd() {
		//(GeneticExecutor)ga_wcet_generator -> pc = mk_and(best_profile.get("pc"))
	}
	
	public void mkImplies() {
		
	}
	
	public void solverAssert() {
		//(GeneticExecutor)ga_wcet_generator -> solver_assert(solver, pc)
	}
	
	public void quickCheck() {
		
	}
	
	public void isContradiction() {
		
	}
	
	public void isTautology() {
		
	}
	
	public void isImplied() {
		
	}
	
	public void isInconsistent() {
		//CrossoverFunction -> singlePointCrossover
	}
	
	public void minimize() {
		//class INDIVIDUAL
	}
	
	public void countInstructions() {
		//GeneticExecutor -> run
	}
	
}
